import random

# actual_price is not random but generated by a polynomial

training_data = [
    (156, 80, 100, 23336),
    (876, 50, 25, 762625),
    (345, 100, 100, 109325),
    (789, 60, 30, 617631),
    (234, 80, 100, 36696),
    (987, 50, 25, 924374),
    (456, 100, 100, 206736),
    (678, 60, 30, 455718),
    (123, 80, 100, 6229),
    (890, 50, 25, 792525),
    (567, 100, 100, 311089),
    (765, 60, 30, 580665),
    (321, 80, 100, 9481),
    (901, 50, 25, 806326),
    (654, 100, 100, 416616),
    (743, 60, 30, 549379),
    (210, 80, 100, 36100),
    (912, 50, 25, 826769),
    (432, 100, 100, 176144),
    (721, 60, 30, 509871),
    (198, 80, 100, 23204),
    (923, 50, 25, 847054),
    (543, 100, 100, 284349),
    (700, 60, 30, 484030),
    (187, 80, 100, 14969),
    (934, 50, 25, 867281),
    (632, 100, 100, 389424),
    (689, 60, 30, 464751),
    (176, 80, 100, 10096),
    (945, 50, 25, 887470),
    (710, 100, 100, 494000),
    (667, 60, 30, 434889),
    (165, 80, 100, 6225),
    (956, 50, 25, 907621),
    (721, 100, 100, 509841),
    (655, 60, 30, 418055),
    (154, 80, 100, 2116),
    (967, 50, 25, 927734),
    (732, 100, 100, 526224),
    (643, 60, 30, 401669),
    (143, 80, 100, -2631),
    (978, 50, 25, 947813),
    (743, 100, 100, 549349),
    (631, 60, 30, 385151),
    (132, 80, 100, -6816),
    (989, 50, 25, 967862),
    (754, 100, 100, 570516),
    (619, 60, 30, 368591),
    (121, 80, 100, -10459),
    (100, 50, 25, 9525),
    (765, 100, 100, 591225),
    (607, 60, 30, 351979),
    (200, 100, 100, 30100),
    (800, 80, 100, 560100),
    (300, 60, 30, 72030),
    (900, 50, 25, 765025),
    (400, 100, 100, 150100),
    (700, 80, 100, 430100),
    (500, 60, 30, 220030),
    (600, 100, 100, 300100),
    (850, 80, 100, 652600),
    (250, 60, 30, 47030),
    (950, 50, 25, 855025),
    (350, 100, 100, 112600),
    (750, 80, 100, 502600),
    (450, 60, 30, 177030),
    (550, 100, 100, 252600),
    (825, 80, 100, 605725),
    (275, 60, 30, 59530),
    (925, 50, 25, 816900),
    (375, 100, 100, 130725),
    (725, 80, 100, 466925),
    (475, 60, 30, 199530),
    (575, 100, 100, 280725),
    (875, 80, 100, 702625),
    (225, 60, 30, 35030),
    (975, 50, 25, 900650),
    (425, 100, 100, 170625),
    (675, 80, 100, 425625),
    (525, 60, 30, 245630),
    (625, 100, 100, 330625),
    (837, 80, 100, 620769),
    (262, 60, 30, 53544),
    (937, 50, 25, 839364),
    (362, 100, 100, 121044),
    (737, 80, 100, 483769),
    (487, 60, 30, 209)]

training_data = [(size, loc_value, prox, actual_price/1000) for size, loc_value, prox, actual_price in training_data]



learning_rate = 0.000001
epochs = 1000000
decay_rate = 0.9999




actual_prices = tuple(price for _, _, _, price in training_data)

loc_input = input("Enter location (Metropolis, City, Town, Village): ").strip().capitalize()

if loc_input == "Metropolis":
    loc_value = float(100)
elif loc_input == "City":
    loc_value = float(80)
elif loc_input == "Town":
    loc_value = float(60)
elif loc_input == "Village":
    loc_value = float(50)
else:
    print("Invalid location entered.")
    exit()

size = int(input("Enter size in sq feet: "))

if loc_value == 100 or loc_value == 80:
    prox = 100
else:
    prox = loc_value / 2

w1 = 10
w2 = 10
w3 = 10


def landPrice(size, loc_value, prox):
    price = (size * w1 + prox * w2 + loc_value * w3 )/1000
    return price

predicted_prices = []
for size, loc_value, prox,  _ in training_data:
    predicted_price = landPrice(size, loc_value, prox)
    predicted_prices.append(predicted_price)

print("Predicted Prices:", predicted_prices)
print(f"Actual prices:{actual_prices}")

def calculate_cost(predicted_prices, actual_prices):
    if len(predicted_prices) != len(actual_prices):
        raise ValueError("Predicted and actual price lists must have the same length.")

    squared_errors = [(predicted - actual) ** 2 for predicted, actual in zip(predicted_prices, actual_prices)]
    mean_squared_error = sum(squared_errors) / len(squared_errors)
    return mean_squared_error

cost = calculate_cost(predicted_prices, actual_prices)
print("Mean Squared Error (MSE):", cost)

def calculate_gradients(predicted_prices, actual_prices, training_data):
    dw1 = 0
    dw2 = 0
    dw3 = 0
    n = len(training_data)

    for i in range(n):
        size, loc_value, prox, _ = training_data[i]
        error = predicted_prices[i] - actual_prices[i]
        dw1 = dw1 + 2 * error * size
        dw2 = dw2 + 2 * error * prox
        dw3 = dw3 + 2 * error * loc_value

    dw1 = dw1 / n
    dw2 = dw2 / n
    dw3 = dw3 / n

    return dw1, dw2, dw3

def update_weights(w1, w2, w3, dw1, dw2, dw3,  learning_rate):
    w1 = w1 - learning_rate * dw1
    w2 = w2 - learning_rate * dw2
    w3 = w3 - learning_rate * dw3
    return w1, w2, w3

for epoch in range(epochs):
    predicted_prices = [] # Reset the lists at the start of each epoch
    actual_prices = []
    

    for size, loc_value, prox, actual_price in training_data:
        predicted_price = landPrice(size, loc_value, prox)
        predicted_prices.append(predicted_price)
        actual_prices.append(actual_price)

    dw1, dw2, dw3= calculate_gradients(predicted_prices, actual_prices, training_data)
    w1, w2, w3 = update_weights(w1, w2, w3, dw1, dw2, dw3, learning_rate)

    

    if epoch % 100000 == 0:
        
        cost = calculate_cost(predicted_prices, actual_prices)
        print(f"Epoch :{epoch} , Cost :{cost}")

print(f"w1 :{w1}, w2 :{w2}, w3 :{w3}")

print(f"The cost of the input you provided is :{size*w1 + loc_value*w2 + prox*w3}")